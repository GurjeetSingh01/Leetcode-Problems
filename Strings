QUESTION-1: VALID-PARENTHESES/

JAVA LEETCODE SOLUTION 

public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            if(a == '(' || a == '[' || a == '{') stack.push(a);
            else if(stack.empty()) return false;
            else if(a == ')' && stack.pop() != '(') return false;
            else if(a == ']' && stack.pop() != '[') return false;
            else if(a == '}' && stack.pop() != '{') return false;
        }
        return stack.empty();
    }
}



QUESTION-2: PRINT ALL THE DUPLICATES IN THE STRING/

JAVA SOLUTION

public class Main {
public static void main(String[] args) {
String sentence = "How many duplicates are there?";
String characters = "";
String duplicates = "";
for(int i =0; i<sentence.length(); i++){
String current = Character.toString(sentence.charAt(i));

if(characters.contains(current)){
if(!duplicates.contains(current)) {
duplicates += current + ", ";
}
}
characters += current; 
}
System.out.println(duplicates);
}
}


QUESTION-3: IMPLEMENT STRSTR

class Solution {
    public int strStr(String haystack, String needle) {
    
  for (int i = 0; ; i++) {
    for (int j = 0; ; j++) {
      if (j == needle.length()) return i;
      if (i + j == haystack.length()) return -1;
      if (needle.charAt(j) != haystack.charAt(i + j)) break;
    }
  }
}    
}

QUESTION-4: Longest Common Prefix

class Solution {
    public String longestCommonPrefix(String[] strs) {
       if(strs == null || strs.length ==0) 
           return "";
        String pre = strs[0];
        int i =1;
        while(i<strs.length){
            while(strs[i].indexOf(pre)!=0)
                pre= pre.substring(0, pre.length()-1);
            i++;
        }
        return pre;
    }
}



QUESTION-5: VALID PALINDROME-II
class Solution {
public boolean validPalindrome(String s) {
return isPalindrome(s,0,s.length()-1, 1);
}
public boolean isPalindrome(String str, int start , int end, int chance){
if(start >=end) return true; 
if(str.charAt(start) == str.charAt(end))
return isPalindrome(str, start+1, end-1, chance);

if(chance ==0) return false; 
return isPalindrome(str, start+1, end , chance-1) || isPalindrome(str, start , end-1, chance-1);
}
}

   
 
QUESTION-6: INTEGER-TO-ROMAN

class Solution {
public String intToRoman(int num) {
  int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
    String[] romanNumerals ={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"}; 
    StringBuilder sb = new StringBuilder();
   for (int i = 0; i < values.length; i++) {
        
        while(num >= values[i]) {
            num -= values[i];
            sb.append(romanNumerals[i]);
        }}
    return sb.toString();  
}
}

QUESTION -7: Generate- parentheses
//USING BACKTRACKING 
class Solution {
   public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<String>();
        backtrack(list, "", 0, 0, n);
        return list;
    }
    public void backtrack(List<String> list, String str, int open, int close, int max){
    
    if(str.length() == max*2){
        list.add(str);
        return;
    }
    
    if(open < max)
        backtrack(list, str+"(", open+1, close, max);
    if(close < open)
        backtrack(list, str+")", open, close+1, max);
}
}
QUESTION-8: Simplify-Path

class Solution {
    public String simplifyPath(String path) {
        String[] dirs= path.split("/");
        Deque<String> stack = new ArrayDeque<>();
        for(String s: dirs){
            if(s.equals("")) continue; 
            if(s.equals(".")) continue; 
            if(s.equals("..")) stack.pollLast();
            else stack.add(s);
        }
        return "/" + String.join("/", stack);
    }
}

QUESTION--9: MINIMUM SLIDING WINDOW
public static String smallestWindow(String s, String p)
   {
       if(s==null || p==null || p.length()==0 || s.length()==0)
       {
           return "-1";
       }
       
       String ans="";
       int anslength=Integer.MAX_VALUE;
       
       HashMap<Character,Integer> small= new HashMap<>();
       
       for(int i=0;i<p.length();i++)
       {
           char ch=p.charAt(i);
           small.put(ch,small.getOrDefault(ch,0)+1);
       }
       
       HashMap<Character,Integer> big= new HashMap<>();
       int DesiredMatchCount=p.length();
       int MatchCount=0;
       
       int i=0;
       int j=0;
       
       while(i<s.length())
       {
           while(i<s.length() && MatchCount<DesiredMatchCount)
           {
               char ch=s.charAt(i);
               big.put(ch,big.getOrDefault(ch,0)+1);
               if(big.getOrDefault(ch,0)<=small.getOrDefault(ch,0))
               {
                   MatchCount++;
               }
               i++;
           }
           
           while(j<i && MatchCount==DesiredMatchCount)
           {
               int minlength=i-j;
               if(minlength<anslength)
               {
                   anslength=minlength;
                   ans=s.substring(j,i);
               }
               
               char ch=s.charAt(j);
               if (big.get(ch)==1)
               {
                   big.remove(ch);
               }
               else
               {
                   big.put(ch,big.get(ch)-1);
               }
               
               if(big.getOrDefault(ch,0)<small.getOrDefault(ch,0))
               {
                   MatchCount--;
               }
               j++;
           }
       }
       if(ans=="")
       {
           return "-1";
       }
       return ans;
       
   }


QUESTION:10- REVERSE WORDS IN A STRING 

class Solution {
   public String reverseWords(String s) {
        Stack<String> st = new Stack<String>();
        for (String a : s.trim().split(" ")) {
            if (!a.isEmpty())
                st.push(a);
        }
        
        StringBuilder sb = new StringBuilder();
        while (!st.isEmpty()) {
            sb.append(st.pop());
            sb.append(" ");            
        }
        
        return sb.toString().trim();
    }
}

QUESTION:-11 GROUP ANAGRAMS

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();

        for(String st:strs){
            char[] ch = st.toCharArray();
            Arrays.sort(ch);
            String ss = String.valueOf(ch);
            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());
            mpp.get(ss).add(st);
        }
        return new ArrayList<>(mpp.values());
    }

}
