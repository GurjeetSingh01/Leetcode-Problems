QUESTION-1: VALID-PARENTHESES/

JAVA LEETCODE SOLUTION 

public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            if(a == '(' || a == '[' || a == '{') stack.push(a);
            else if(stack.empty()) return false;
            else if(a == ')' && stack.pop() != '(') return false;
            else if(a == ']' && stack.pop() != '[') return false;
            else if(a == '}' && stack.pop() != '{') return false;
        }
        return stack.empty();
    }
}



QUESTION-2: PRINT ALL THE DUPLICATES IN THE STRING/

JAVA SOLUTION

public class Main {
public static void main(String[] args) {
String sentence = "How many duplicates are there?";
String characters = "";
String duplicates = "";
for(int i =0; i<sentence.length(); i++){
String current = Character.toString(sentence.charAt(i));

if(characters.contains(current)){
if(!duplicates.contains(current)) {
duplicates += current + ", ";
}
}
characters += current; 
}
System.out.println(duplicates);
}
}


QUESTION-3: IMPLEMENT STRSTR

class Solution {
    public int strStr(String haystack, String needle) {
    
  for (int i = 0; ; i++) {
    for (int j = 0; ; j++) {
      if (j == needle.length()) return i;
      if (i + j == haystack.length()) return -1;
      if (needle.charAt(j) != haystack.charAt(i + j)) break;
    }
  }
}    
}

QUESTION-4: Longest Common Prefix

class Solution {
    public String longestCommonPrefix(String[] strs) {
       if(strs == null || strs.length ==0) 
           return "";
        String pre = strs[0];
        int i =1;
        while(i<strs.length){
            while(strs[i].indexOf(pre)!=0)
                pre= pre.substring(0, pre.length()-1);
            i++;
        }
        return pre;
    }
}



QUESTION-5: VALID PALINDROME-II
class Solution {
public boolean validPalindrome(String s) {
return isPalindrome(s,0,s.length()-1, 1);
}
public boolean isPalindrome(String str, int start , int end, int chance){
if(start >=end) return true; 
if(str.charAt(start) == str.charAt(end))
return isPalindrome(str, start+1, end-1, chance);

if(chance ==0) return false; 
return isPalindrome(str, start+1, end , chance-1) || isPalindrome(str, start , end-1, chance-1);
}
}

   
 
QUESTION-6: INTEGER-TO-ROMAN

class Solution {
public String intToRoman(int num) {
  int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
    String[] romanNumerals ={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"}; 
    StringBuilder sb = new StringBuilder();
   for (int i = 0; i < values.length; i++) {
        
        while(num >= values[i]) {
            num -= values[i];
            sb.append(romanNumerals[i]);
        }}
    return sb.toString();  
}
}

QUESTION -7: Generate- parentheses
//USING BACKTRACKING 
class Solution {
   public List<String> generateParenthesis(int n) {
        List<String> list = new ArrayList<String>();
        backtrack(list, "", 0, 0, n);
        return list;
    }
    public void backtrack(List<String> list, String str, int open, int close, int max){
    
    if(str.length() == max*2){
        list.add(str);
        return;
    }
    
    if(open < max)
        backtrack(list, str+"(", open+1, close, max);
    if(close < open)
        backtrack(list, str+")", open, close+1, max);
}
}
QUESTION-8: Simplify-Path

class Solution {
    public String simplifyPath(String path) {
        String[] dirs= path.split("/");
        Deque<String> stack = new ArrayDeque<>();
        for(String s: dirs){
            if(s.equals("")) continue; 
            if(s.equals(".")) continue; 
            if(s.equals("..")) stack.pollLast();
            else stack.add(s);
        }
        return "/" + String.join("/", stack);
    }
}

QUESTION--9: MINIMUM SLIDING WINDOW
public static String smallestWindow(String s, String p)
   {
       if(s==null || p==null || p.length()==0 || s.length()==0)
       {
           return "-1";
       }
       
       String ans="";
       int anslength=Integer.MAX_VALUE;
       
       HashMap<Character,Integer> small= new HashMap<>();
       
       for(int i=0;i<p.length();i++)
       {
           char ch=p.charAt(i);
           small.put(ch,small.getOrDefault(ch,0)+1);
       }
       
       HashMap<Character,Integer> big= new HashMap<>();
       int DesiredMatchCount=p.length();
       int MatchCount=0;
       
       int i=0;
       int j=0;
       
       while(i<s.length())
       {
           while(i<s.length() && MatchCount<DesiredMatchCount)
           {
               char ch=s.charAt(i);
               big.put(ch,big.getOrDefault(ch,0)+1);
               if(big.getOrDefault(ch,0)<=small.getOrDefault(ch,0))
               {
                   MatchCount++;
               }
               i++;
           }
           
           while(j<i && MatchCount==DesiredMatchCount)
           {
               int minlength=i-j;
               if(minlength<anslength)
               {
                   anslength=minlength;
                   ans=s.substring(j,i);
               }
               
               char ch=s.charAt(j);
               if (big.get(ch)==1)
               {
                   big.remove(ch);
               }
               else
               {
                   big.put(ch,big.get(ch)-1);
               }
               
               if(big.getOrDefault(ch,0)<small.getOrDefault(ch,0))
               {
                   MatchCount--;
               }
               j++;
           }
       }
       if(ans=="")
       {
           return "-1";
       }
       return ans;
       
   }


QUESTION:10- REVERSE WORDS IN A STRING 

class Solution {
   public String reverseWords(String s) {
        Stack<String> st = new Stack<String>();
        for (String a : s.trim().split(" ")) {
            if (!a.isEmpty())
                st.push(a);
        }
        
        StringBuilder sb = new StringBuilder();
        while (!st.isEmpty()) {
            sb.append(st.pop());
            sb.append(" ");            
        }
        
        return sb.toString().trim();
    }
}

QUESTION:-11 GROUP ANAGRAMS

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();

        for(String st:strs){
            char[] ch = st.toCharArray();
            Arrays.sort(ch);
            String ss = String.valueOf(ch);
            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());
            mpp.get(ss).add(st);
        }
        return new ArrayList<>(mpp.values());
    }

}

QUESTION:-11 BASIC CALCULATOR II
public class Solution {
public int calculate(String s) {
    int res = 0, pre = 0, curr = 0;
    char sign = '+';
    char[] array = s.trim().toCharArray();
    for(int i=0; i<=array.length; i++){
        if(i!=array.length && Character.isDigit(array[i]))
            curr = curr*10 + array[i]-'0';
        else{
            if(i!=array.length && array[i]==' ') continue;
            if(sign=='+'){
                res += curr;
                pre = curr;
            }
            if(sign=='-'){
                res -= curr;
                pre = -curr;
            }
            if(sign=='*'){
                res = res - pre + pre*curr;
                pre = pre*curr;
            }
            if(sign=='/'){
                res = res - pre + pre/curr;
                pre = pre/curr;
            }
            curr = 0;
            if(i!=array.length) sign = array[i];
        }
    }
    return res;
}
}

QUESTION: -12 VALID NUMBER(HARD) 
class Solution {
    public boolean isNumber(String s) {
        
        if (s == null || s.length () == 0) {
            return false;
        }
        
        boolean eSeen = false;
        boolean numberSeen = false;
        boolean decimalSeen = false;
        
        for (int i = 0; i < s.length (); i++) {
            char c = s.charAt (i);
            if (c >= 48 && c <= 57) {
                numberSeen = true;
            }
            else if (c == '+' || c == '-') {
                if (i == s.length () - 1 || (i != 0 && s.charAt (i - 1) != 'e' && s.charAt (i - 1) != 'E')) {
                    return false;
                }
            }
            else if (c == '.') {
                if (eSeen || decimalSeen) {
                    return false;
                }
                
                decimalSeen = true;
            }
            else if (c == 'e' || c == 'E') {
                if (i == s.length () - 1 || eSeen || !numberSeen) {
                    return false;
                }
                
                eSeen = true;
            }
            else {
                return false;
            }
        }
        
        return numberSeen;
    }
}

QUESTION:13 INTEGER TO ENGLISH WORDS

class Solution {
   private String[] digit = new String[] {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
private String[] teen = new String[] {"Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
private String[] ten = new String[] {"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
private String[] thousand = new String[] {"Thousand", "Million", "Billion"};

public String numberToWords(int num) {
	String ans;
	if (num == 0)
		return digit[num];
	
	ans = hundredHelper(num%1000);
	num = num/1000;
	int i = 0;
	while (i < 3 && num > 0) {
		if (num % 1000 > 0)
			ans = hundredHelper(num%1000) + thousand[i] + " " + ans;
		num = num/1000;
		i++;
	}
	
	return ans.trim();
}

public String hundredHelper(int num) {
	String nstr = "";
	if (num >= 100) {
		nstr = digit[num/100] + " Hundred ";
	}
	num = num%100;
	if (num >= 20) {
		if (num % 10 != 0)
			nstr = nstr + ten[num/10 - 2] + " " +  digit[num%10] + " ";
		else
			nstr = nstr + ten[num/10 - 2] + " ";
	} else if (num >= 10) {
		nstr = nstr + teen[num%10] + " ";
	} else if (num > 0){
		nstr = nstr + digit[num] + " ";
	}
	return nstr;
}
}

QUESTION:14 MINIMUM WINDOW SUBSTRING

