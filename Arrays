QUESTION 1: FIND THE DUPLICATE NUMBER

class Solution {
    public int findDuplicate(int[] nums){
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums.length; 
        for(int i =0; i<nums.length; i++){
            if(map.containsKey(nums[i])) 
                return nums[i];
            else{
                map.put(nums[i],1);
            }
        }
        return -1; 
    }
}

QUESTION 2: SORT COLORS

class Solution {
    
public static void sortColors(int[] arr) {
int l=0;
int m=0; 
int h=arr.length-1;
while(m<=h)
{
    if(arr[m]==0){ //element is 0
        swap(arr,l,m);
        l++;
        m++;
    } else if(arr[m]==2){
        swap(arr,m,h);
        h--;
    }
    else m++;
}
  }
  
 private static void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}

QUESTION 3: REMOVE DUPLICATES FROM SORTED ARRAY

class Solution {
    public int removeDuplicates(int[] nums) {
      if(nums.length == 0) return 0;
      int res = 1;
      for(int i = 1; i < nums.length; i++){
        if(nums[i] != nums[i - 1]){
          nums[res] = nums[i];
          res++;
        }
      }
      return res;
    }
}

QUESTION 4: SET MATRIX ZEROES


import java.util.*;
class Solution{
static void setZeroes(int[][] matrix) {
        int col0 = 1, rows = matrix.length, cols = matrix[0].length;

        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) col0 = 0;
            for (int j = 1; j < cols; j++)
                if (matrix[i][j] == 0)
                    matrix[i][0] = matrix[0][j] = 0;
        }

        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 1; j--)
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            if (col0 == 0) matrix[i][0] = 0;
        } }
public static void main(String args[]) {
        int arr[][] = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};
        setZeroes(arr);
        System.out.println("The Final Matrix is ");
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
}
}

QUESTION 5: MOVE ZEROES 
class Solution {
       
public void moveZeroes(int[] nums) {
    int zero = 0, l = 0, r = nums.length;
    while (l < r) {
        if (nums[l] != 0) {
            int tmp = nums[zero];
            nums[zero++] = nums[l];
            nums[l] = tmp;
        }
        l++;
    }
}}    
    
QUESTION 6: BEST TIME TO BUY AND SELL STOCK I
class Solution {
    public int maxProfit(int[] prices) {
        int lsf = Integer.MAX_VALUE;
        int op = 0;
        int pist = 0;
        
        for(int i = 0; i < prices.length; i++){
            if(prices[i] < lsf){
                lsf = prices[i];
            }
            pist = prices[i] - lsf;
            if(op < pist){
                op = pist;
            }
        }
        return op;
    }
}

QUESTION 7: TWO SUM 
class Solution {
    public int[] twoSum(int[] nums, int target) {
      int num1 , num2; 
      for(int i=0; i<nums.length; i++){
          num1 = nums[i];
          for(int j=i+1; j<nums.length; j++){
              num2 = nums[j];
              if(num1 + num2 == target) return new int[]{i, j};
          }
      }
      return null;
    }
}

QUESTION 8: BEST TIME TO BUY AND SELL STOCK II 
class Solution {
    public int maxProfit(int[] prices) {
        int bd = 0; // buy date
        int sd = 0; // sell date
        int profit = 0; // overall profit after selling
        for(int i = 1; i < prices.length; i++){ // run a loop from 1 because on 0th day we buy the stock and after 1 or on 1 we can sell it. and so on
            if(prices[i] >= prices[i - 1]){ // check if previous selling price is lesser then the current one
                sd++;
            }
            else{ // otherwise, calculate the profit before the drop down
                profit += prices[sd] - prices[bd];
                bd = sd = i; // and move to new buy and sell day
            }
        }
        profit += prices[sd] - prices[bd]; // again compare n check it
        return profit; 
    }
}

QUESTION 9: Subarray Sums Divisible by K
class Solution {
    public int subarraysDivByK(int[] arr, int k) {
        int count=0,sum=0;
		int rem;
        int n=arr.length;
		HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
		map.put(0, 1);//save rem and its freq
		for(int i=0;i<n;i++)
		{
			sum=sum+arr[i];
			rem=sum%k;
			if(rem<0)
			{
				rem+=k;
			}
			if(map.containsKey(rem))
			{
				count=count+map.get(rem);
				map.put(rem, map.get(rem)+1);
			}
			else
			{
				map.put(rem, 1);
			}
		}
		return count;
    }
}

QUESTION 10: FIND ALL DUPLICATES IN AN ARRAY
