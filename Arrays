QUESTION 1: FIND THE DUPLICATE NUMBER

class Solution {
    public int findDuplicate(int[] nums){
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums.length; 
        for(int i =0; i<nums.length; i++){
            if(map.containsKey(nums[i])) 
                return nums[i];
            else{
                map.put(nums[i],1);
            }
        }
        return -1; 
    }
}

QUESTION 2: SORT COLORS

class Solution {
    
public static void sortColors(int[] arr) {
int l=0;
int m=0; 
int h=arr.length-1;
while(m<=h)
{
    if(arr[m]==0){ //element is 0
        swap(arr,l,m);
        l++;
        m++;
    } else if(arr[m]==2){
        swap(arr,m,h);
        h--;
    }
    else m++;
}
  }
  
 private static void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
}

QUESTION 3: REMOVE DUPLICATES FROM SORTED ARRAY

class Solution {
    public int removeDuplicates(int[] nums) {
      if(nums.length == 0) return 0;
      int res = 1;
      for(int i = 1; i < nums.length; i++){
        if(nums[i] != nums[i - 1]){
          nums[res] = nums[i];
          res++;
        }
      }
      return res;
    }
}

QUESTION 4: SET MATRIX ZEROES


import java.util.*;
class Solution{
static void setZeroes(int[][] matrix) {
        int col0 = 1, rows = matrix.length, cols = matrix[0].length;

        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) col0 = 0;
            for (int j = 1; j < cols; j++)
                if (matrix[i][j] == 0)
                    matrix[i][0] = matrix[0][j] = 0;
        }

        for (int i = rows - 1; i >= 0; i--) {
            for (int j = cols - 1; j >= 1; j--)
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            if (col0 == 0) matrix[i][0] = 0;
        } }
public static void main(String args[]) {
        int arr[][] = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};
        setZeroes(arr);
        System.out.println("The Final Matrix is ");
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
}
}

QUESTION 5: MOVE ZEROES 
class Solution {
       
public void moveZeroes(int[] nums) {
    int zero = 0, l = 0, r = nums.length;
    while (l < r) {
        if (nums[l] != 0) {
            int tmp = nums[zero];
            nums[zero++] = nums[l];
            nums[l] = tmp;
        }
        l++;
    }
}}    
    
QUESTION 6: BEST TIME TO BUY AND SELL STOCK I
class Solution {
    public int maxProfit(int[] prices) {
        int lsf = Integer.MAX_VALUE;
        int op = 0;
        int pist = 0;
        
        for(int i = 0; i < prices.length; i++){
            if(prices[i] < lsf){
                lsf = prices[i];
            }
            pist = prices[i] - lsf;
            if(op < pist){
                op = pist;
            }
        }
        return op;
    }
}

QUESTION 7: TWO SUM 
class Solution {
    public int[] twoSum(int[] nums, int target) {
      int num1 , num2; 
      for(int i=0; i<nums.length; i++){
          num1 = nums[i];
          for(int j=i+1; j<nums.length; j++){
              num2 = nums[j];
              if(num1 + num2 == target) return new int[]{i, j};
          }
      }
      return null;
    }
}

QUESTION 8: BEST TIME TO BUY AND SELL STOCK II 
class Solution {
    public int maxProfit(int[] prices) {
        int bd = 0; // buy date
        int sd = 0; // sell date
        int profit = 0; // overall profit after selling
        for(int i = 1; i < prices.length; i++){ // run a loop from 1 because on 0th day we buy the stock and after 1 or on 1 we can sell it. and so on
            if(prices[i] >= prices[i - 1]){ // check if previous selling price is lesser then the current one
                sd++;
            }
            else{ // otherwise, calculate the profit before the drop down
                profit += prices[sd] - prices[bd];
                bd = sd = i; // and move to new buy and sell day
            }
        }
        profit += prices[sd] - prices[bd]; // again compare n check it
        return profit; 
    }
}

QUESTION 9: Subarray Sums Divisible by K
class Solution {
    public int subarraysDivByK(int[] arr, int k) {
        int count=0,sum=0;
		int rem;
        int n=arr.length;
		HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();
		map.put(0, 1);//save rem and its freq
		for(int i=0;i<n;i++)
		{
			sum=sum+arr[i];
			rem=sum%k;
			if(rem<0)
			{
				rem+=k;
			}
			if(map.containsKey(rem))
			{
				count=count+map.get(rem);
				map.put(rem, map.get(rem)+1);
			}
			else
			{
				map.put(rem, 1);
			}
		}
		return count;
    }
}

QUESTION 10: FIND ALL DUPLICATES IN AN ARRAY
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        
        for (int i = 0; i < nums.length; i++) {
            
            int idx = Math.abs(nums[i]) - 1; // Get the mapped index for nums[i], using Math.abs only once
            
            if (nums[idx] < 0) // Check if nums[i] has been seen before, if true then add to the output list
                res.add(idx + 1); // Need to add +1 as our range is 1-based
            
            nums[idx] *= -1; // Unconditionally flip the sign, if it's positive, we want to mark it as negative. But if it's negative, we just recover previous value so that at the end our array is not modified
        }
        
        return res;
    }
}

QUESTIION 11: CONTAINER WITH MOST WATER
class Solution {
public int maxArea(int[] height) {
int max_area=0;
int a_pointer=0;
int b_pointer = height.length-1;
 while(a_pointer<b_pointer){
if(height[a_pointer] < height[b_pointer]){
max_area = Math.max(max_area, height[a_pointer] * (b_pointer-a_pointer));
a_pointer +=1;
}
else 
{
max_area = Math.max(max_area, height[b_pointer] * (b_pointer-a_pointer));
b_pointer -=1;
}
}
return max_area;
}
}

QUESTION : 11 3SUM

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        
        int target = 0;
        ArrayList<List<Integer>> sol = new ArrayList<List<Integer>>();
        if(nums == null || nums.length == 0){
            return sol;
        }
        Arrays.sort(nums);
        for(int i = 0 ; i<=nums.length-1 ;i++){
           
                int remaining  = target - nums[i] ;
                int front = i+1;
                int back = nums.length-1;
            
                while(front < back){
                    int twoSum = nums[front] + nums[back];
                    if(twoSum < remaining)front++;
                    else if(twoSum >remaining)back--;
                    else{
                        List<Integer> triplet = new ArrayList<>();
                        triplet.add(nums[i]);
                        triplet.add(nums[front]);
                        triplet.add(nums[back]);
                        sol.add(triplet);

                        while(front < back && nums[front] == triplet.get(1))front++;
                        while(front < back && nums[back] == triplet.get(2))back--;  
                    }
                }
            while( i+1<=nums.length-1 && nums[i] == nums[i+1]) i++;
        }
        return sol;
    }
}

QUESTION 12:
